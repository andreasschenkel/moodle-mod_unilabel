{"version":3,"file":"utils.min.js","sources":["../src/utils.js"],"sourcesContent":["import { IE11OrLess } from './BrowserInfo.js';\nimport Sortable from './Sortable.js';\n\nconst captureMode = {\n\tcapture: false,\n\tpassive: false\n};\n\nfunction on(el, event, fn) {\n\tel.addEventListener(event, fn, !IE11OrLess && captureMode);\n}\n\n\nfunction off(el, event, fn) {\n\tel.removeEventListener(event, fn, !IE11OrLess && captureMode);\n}\n\nfunction matches(/**HTMLElement*/el, /**String*/selector) {\n\tif (!selector) return;\n\n\tselector[0] === '>' && (selector = selector.substring(1));\n\n\tif (el) {\n\t\ttry {\n\t\t\tif (el.matches) {\n\t\t\t\treturn el.matches(selector);\n\t\t\t} else if (el.msMatchesSelector) {\n\t\t\t\treturn el.msMatchesSelector(selector);\n\t\t\t} else if (el.webkitMatchesSelector) {\n\t\t\t\treturn el.webkitMatchesSelector(selector);\n\t\t\t}\n\t\t} catch(_) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nfunction getParentOrHost(el) {\n\treturn (el.host && el !== document && el.host.nodeType)\n\t\t? el.host\n\t\t: el.parentNode;\n}\n\nfunction closest(/**HTMLElement*/el, /**String*/selector, /**HTMLElement*/ctx, includeCTX) {\n\tif (el) {\n\t\tctx = ctx || document;\n\n\t\tdo {\n\t\t\tif (\n\t\t\t\tselector != null &&\n\t\t\t\t(\n\t\t\t\t\tselector[0] === '>' ?\n\t\t\t\t\tel.parentNode === ctx && matches(el, selector) :\n\t\t\t\t\tmatches(el, selector)\n\t\t\t\t) ||\n\t\t\t\tincludeCTX && el === ctx\n\t\t\t) {\n\t\t\t\treturn el;\n\t\t\t}\n\n\t\t\tif (el === ctx) break;\n\t\t\t/* jshint boss:true */\n\t\t} while (el = getParentOrHost(el));\n\t}\n\n\treturn null;\n}\n\nconst R_SPACE = /\\s+/g;\n\nfunction toggleClass(el, name, state) {\n\tif (el && name) {\n\t\tif (el.classList) {\n\t\t\tel.classList[state ? 'add' : 'remove'](name);\n\t\t}\n\t\telse {\n\t\t\tlet className = (' ' + el.className + ' ').replace(R_SPACE, ' ').replace(' ' + name + ' ', ' ');\n\t\t\tel.className = (className + (state ? ' ' + name : '')).replace(R_SPACE, ' ');\n\t\t}\n\t}\n}\n\n\nfunction css(el, prop, val) {\n\tlet style = el && el.style;\n\n\tif (style) {\n\t\tif (val === void 0) {\n\t\t\tif (document.defaultView && document.defaultView.getComputedStyle) {\n\t\t\t\tval = document.defaultView.getComputedStyle(el, '');\n\t\t\t}\n\t\t\telse if (el.currentStyle) {\n\t\t\t\tval = el.currentStyle;\n\t\t\t}\n\n\t\t\treturn prop === void 0 ? val : val[prop];\n\t\t}\n\t\telse {\n\t\t\tif (!(prop in style) && prop.indexOf('webkit') === -1) {\n\t\t\t\tprop = '-webkit-' + prop;\n\t\t\t}\n\n\t\t\tstyle[prop] = val + (typeof val === 'string' ? '' : 'px');\n\t\t}\n\t}\n}\n\nfunction matrix(el, selfOnly) {\n\tlet appliedTransforms = '';\n\tif (typeof(el) === 'string') {\n\t\tappliedTransforms = el;\n\t} else {\n\t\tdo {\n\t\t\tlet transform = css(el, 'transform');\n\n\t\t\tif (transform && transform !== 'none') {\n\t\t\t\tappliedTransforms = transform + ' ' + appliedTransforms;\n\t\t\t}\n\t\t\t/* jshint boss:true */\n\t\t} while (!selfOnly && (el = el.parentNode));\n\t}\n\n\tconst matrixFn = window.DOMMatrix || window.WebKitCSSMatrix || window.CSSMatrix || window.MSCSSMatrix;\n\t/*jshint -W056 */\n\treturn matrixFn && (new matrixFn(appliedTransforms));\n}\n\n\nfunction find(ctx, tagName, iterator) {\n\tif (ctx) {\n\t\tlet list = ctx.getElementsByTagName(tagName), i = 0, n = list.length;\n\n\t\tif (iterator) {\n\t\t\tfor (; i < n; i++) {\n\t\t\t\titerator(list[i], i);\n\t\t\t}\n\t\t}\n\n\t\treturn list;\n\t}\n\n\treturn [];\n}\n\n\n\nfunction getWindowScrollingElement() {\n\tlet scrollingElement = document.scrollingElement;\n\n\tif (scrollingElement) {\n\t\treturn scrollingElement\n\t} else {\n\t\treturn document.documentElement\n\t}\n}\n\n\n/**\n * Returns the \"bounding client rect\" of given element\n * @param  {HTMLElement} el                       The element whose boundingClientRect is wanted\n * @param  {[Boolean]} relativeToContainingBlock  Whether the rect should be relative to the containing block of (including) the container\n * @param  {[Boolean]} relativeToNonStaticParent  Whether the rect should be relative to the relative parent of (including) the contaienr\n * @param  {[Boolean]} undoScale                  Whether the container's scale() should be undone\n * @param  {[HTMLElement]} container              The parent the element will be placed in\n * @return {Object}                               The boundingClientRect of el, with specified adjustments\n */\nfunction getRect(el, relativeToContainingBlock, relativeToNonStaticParent, undoScale, container) {\n\tif (!el.getBoundingClientRect && el !== window) return;\n\n\tlet elRect,\n\t\ttop,\n\t\tleft,\n\t\tbottom,\n\t\tright,\n\t\theight,\n\t\twidth;\n\n\tif (el !== window && el.parentNode && el !== getWindowScrollingElement()) {\n\t\telRect = el.getBoundingClientRect();\n\t\ttop = elRect.top;\n\t\tleft = elRect.left;\n\t\tbottom = elRect.bottom;\n\t\tright = elRect.right;\n\t\theight = elRect.height;\n\t\twidth = elRect.width;\n\t} else {\n\t\ttop = 0;\n\t\tleft = 0;\n\t\tbottom = window.innerHeight;\n\t\tright = window.innerWidth;\n\t\theight = window.innerHeight;\n\t\twidth = window.innerWidth;\n\t}\n\n\tif ((relativeToContainingBlock || relativeToNonStaticParent) && el !== window) {\n\t\t// Adjust for translate()\n\t\tcontainer = container || el.parentNode;\n\n\t\t// solves #1123 (see: https://stackoverflow.com/a/37953806/6088312)\n\t\t// Not needed on <= IE11\n\t\tif (!IE11OrLess) {\n\t\t\tdo {\n\t\t\t\tif (\n\t\t\t\t\tcontainer &&\n\t\t\t\t\tcontainer.getBoundingClientRect &&\n\t\t\t\t\t(\n\t\t\t\t\t\tcss(container, 'transform') !== 'none' ||\n\t\t\t\t\t\trelativeToNonStaticParent &&\n\t\t\t\t\t\tcss(container, 'position') !== 'static'\n\t\t\t\t\t)\n\t\t\t\t) {\n\t\t\t\t\tlet containerRect = container.getBoundingClientRect();\n\n\t\t\t\t\t// Set relative to edges of padding box of container\n\t\t\t\t\ttop -= containerRect.top + parseInt(css(container, 'border-top-width'));\n\t\t\t\t\tleft -= containerRect.left + parseInt(css(container, 'border-left-width'));\n\t\t\t\t\tbottom = top + elRect.height;\n\t\t\t\t\tright = left + elRect.width;\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t/* jshint boss:true */\n\t\t\t} while (container = container.parentNode);\n\t\t}\n\t}\n\n\tif (undoScale && el !== window) {\n\t\t// Adjust for scale()\n\t\tlet elMatrix = matrix(container || el),\n\t\t\tscaleX = elMatrix && elMatrix.a,\n\t\t\tscaleY = elMatrix && elMatrix.d;\n\n\t\tif (elMatrix) {\n\t\t\ttop /= scaleY;\n\t\t\tleft /= scaleX;\n\n\t\t\twidth /= scaleX;\n\t\t\theight /= scaleY;\n\n\t\t\tbottom = top + height;\n\t\t\tright = left + width;\n\t\t}\n\t}\n\n\treturn {\n\t\ttop: top,\n\t\tleft: left,\n\t\tbottom: bottom,\n\t\tright: right,\n\t\twidth: width,\n\t\theight: height\n\t};\n}\n\n/**\n * Returns the content rect of the element (bounding rect minus border and padding)\n * @param {HTMLElement} el \n */\nfunction getContentRect(el) {\n\tlet rect = getRect(el);\n\tconst paddingLeft = parseInt(css(el, 'padding-left')),\n\t\tpaddingTop = parseInt(css(el, 'padding-top')),\n\t\tpaddingRight = parseInt(css(el, 'padding-right')),\n\t\tpaddingBottom = parseInt(css(el, 'padding-bottom'));\n\trect.top += paddingTop + parseInt(css(el, 'border-top-width'));\n\trect.left += paddingLeft + parseInt(css(el, 'border-left-width'));\n\t// Client Width/Height includes padding only\n\trect.width = el.clientWidth - paddingLeft - paddingRight;\n\trect.height = el.clientHeight - paddingTop - paddingBottom;\n\trect.bottom = rect.top + rect.height;\n\trect.right = rect.left + rect.width;\n\treturn rect;\n}\n\n/**\n * Checks if a side of an element is scrolled past a side of its parents\n * @param  {HTMLElement}  el           The element who's side being scrolled out of view is in question\n * @param  {String}       elSide       Side of the element in question ('top', 'left', 'right', 'bottom')\n * @param  {String}       parentSide   Side of the parent in question ('top', 'left', 'right', 'bottom')\n * @return {HTMLElement}               The parent scroll element that the el's side is scrolled past, or null if there is no such element\n */\nfunction isScrolledPast(el, elSide, parentSide) {\n\tlet parent = getParentAutoScrollElement(el, true),\n\t\telSideVal = getRect(el)[elSide];\n\n\t/* jshint boss:true */\n\twhile (parent) {\n\t\tlet parentSideVal = getRect(parent)[parentSide],\n\t\t\tvisible;\n\n\t\tif (parentSide === 'top' || parentSide === 'left') {\n\t\t\tvisible = elSideVal >= parentSideVal;\n\t\t} else {\n\t\t\tvisible = elSideVal <= parentSideVal;\n\t\t}\n\n\t\tif (!visible) return parent;\n\n\t\tif (parent === getWindowScrollingElement()) break;\n\n\t\tparent = getParentAutoScrollElement(parent, false);\n\t}\n\n\treturn false;\n}\n\n\n\n/**\n * Gets nth child of el, ignoring hidden children, sortable's elements (does not ignore clone if it's visible)\n * and non-draggable elements\n * @param  {HTMLElement} el       The parent element\n * @param  {Number} childNum      The index of the child\n * @param  {Object} options       Parent Sortable's options\n * @return {HTMLElement}          The child at index childNum, or null if not found\n */\nfunction getChild(el, childNum, options, includeDragEl) {\n\tlet currentChild = 0,\n\t\ti = 0,\n\t\tchildren = el.children;\n\n\twhile (i < children.length) {\n\t\tif (\n\t\t\tchildren[i].style.display !== 'none' &&\n\t\t\tchildren[i] !== Sortable.ghost &&\n\t\t\t(includeDragEl || children[i] !== Sortable.dragged) &&\n\t\t\tclosest(children[i], options.draggable, el, false)\n\t\t) {\n\t\t\tif (currentChild === childNum) {\n\t\t\t\treturn children[i];\n\t\t\t}\n\t\t\tcurrentChild++;\n\t\t}\n\n\t\ti++;\n\t}\n\treturn null;\n}\n\n/**\n * Gets the last child in the el, ignoring ghostEl or invisible elements (clones)\n * @param  {HTMLElement} el       Parent element\n * @param  {selector} selector    Any other elements that should be ignored\n * @return {HTMLElement}          The last child, ignoring ghostEl\n */\nfunction lastChild(el, selector) {\n\tlet last = el.lastElementChild;\n\n\twhile (\n\t\tlast &&\n\t\t(\n\t\t\tlast === Sortable.ghost ||\n\t\t\tcss(last, 'display') === 'none' ||\n\t\t\tselector && !matches(last, selector)\n\t\t)\n\t) {\n\t\tlast = last.previousElementSibling;\n\t}\n\n\treturn last || null;\n}\n\n\n/**\n * Returns the index of an element within its parent for a selected set of\n * elements\n * @param  {HTMLElement} el\n * @param  {selector} selector\n * @return {number}\n */\nfunction index(el, selector) {\n\tlet index = 0;\n\n\tif (!el || !el.parentNode) {\n\t\treturn -1;\n\t}\n\n\t/* jshint boss:true */\n\twhile (el = el.previousElementSibling) {\n\t\tif ((el.nodeName.toUpperCase() !== 'TEMPLATE') && el !== Sortable.clone && (!selector || matches(el, selector))) {\n\t\t\tindex++;\n\t\t}\n\t}\n\n\treturn index;\n}\n\n/**\n * Returns the scroll offset of the given element, added with all the scroll offsets of parent elements.\n * The value is returned in real pixels.\n * @param  {HTMLElement} el\n * @return {Array}             Offsets in the format of [left, top]\n */\nfunction getRelativeScrollOffset(el) {\n\tlet offsetLeft = 0,\n\t\toffsetTop = 0,\n\t\twinScroller = getWindowScrollingElement();\n\n\tif (el) {\n\t\tdo {\n\t\t\tlet elMatrix = matrix(el),\n\t\t\t\tscaleX = elMatrix.a,\n\t\t\t\tscaleY = elMatrix.d;\n\n\t\t\toffsetLeft += el.scrollLeft * scaleX;\n\t\t\toffsetTop += el.scrollTop * scaleY;\n\t\t} while (el !== winScroller && (el = el.parentNode));\n\t}\n\n\treturn [offsetLeft, offsetTop];\n}\n\n/**\n * Returns the index of the object within the given array\n * @param  {Array} arr   Array that may or may not hold the object\n * @param  {Object} obj  An object that has a key-value pair unique to and identical to a key-value pair in the object you want to find\n * @return {Number}      The index of the object in the array, or -1\n */\nfunction indexOfObject(arr, obj) {\n\tfor (let i in arr) {\n\t\tif (!arr.hasOwnProperty(i)) continue;\n\t\tfor (let key in obj) {\n\t\t\tif (obj.hasOwnProperty(key) && obj[key] === arr[i][key]) return Number(i);\n\t\t}\n\t}\n\treturn -1;\n}\n\n\nfunction getParentAutoScrollElement(el, includeSelf) {\n\t// skip to window\n\tif (!el || !el.getBoundingClientRect) return getWindowScrollingElement();\n\n\tlet elem = el;\n\tlet gotSelf = false;\n\tdo {\n\t\t// we don't need to get elem css if it isn't even overflowing in the first place (performance)\n\t\tif (elem.clientWidth < elem.scrollWidth || elem.clientHeight < elem.scrollHeight) {\n\t\t\tlet elemCSS = css(elem);\n\t\t\tif (\n\t\t\t\telem.clientWidth < elem.scrollWidth && (elemCSS.overflowX == 'auto' || elemCSS.overflowX == 'scroll') ||\n\t\t\t\telem.clientHeight < elem.scrollHeight && (elemCSS.overflowY == 'auto' || elemCSS.overflowY == 'scroll')\n\t\t\t) {\n\t\t\t\tif (!elem.getBoundingClientRect || elem === document.body) return getWindowScrollingElement();\n\n\t\t\t\tif (gotSelf || includeSelf) return elem;\n\t\t\t\tgotSelf = true;\n\t\t\t}\n\t\t}\n\t/* jshint boss:true */\n\t} while (elem = elem.parentNode);\n\n\treturn getWindowScrollingElement();\n}\n\nfunction extend(dst, src) {\n\tif (dst && src) {\n\t\tfor (let key in src) {\n\t\t\tif (src.hasOwnProperty(key)) {\n\t\t\t\tdst[key] = src[key];\n\t\t\t}\n\t\t}\n\t}\n\n\treturn dst;\n}\n\n\nfunction isRectEqual(rect1, rect2) {\n\treturn Math.round(rect1.top) === Math.round(rect2.top) &&\n\t\tMath.round(rect1.left) === Math.round(rect2.left) &&\n\t\tMath.round(rect1.height) === Math.round(rect2.height) &&\n\t\tMath.round(rect1.width) === Math.round(rect2.width);\n}\n\n\nlet _throttleTimeout;\nfunction throttle(callback, ms) {\n\treturn function () {\n\t\tif (!_throttleTimeout) {\n\t\t\tlet args = arguments,\n\t\t\t\t_this = this;\n\n\t\t\tif (args.length === 1) {\n\t\t\t\tcallback.call(_this, args[0]);\n\t\t\t} else {\n\t\t\t\tcallback.apply(_this, args);\n\t\t\t}\n\n\t\t\t_throttleTimeout = setTimeout(function () {\n\t\t\t\t_throttleTimeout = void 0;\n\t\t\t}, ms);\n\t\t}\n\t};\n}\n\n\nfunction cancelThrottle() {\n\tclearTimeout(_throttleTimeout);\n\t_throttleTimeout = void 0;\n}\n\n\nfunction scrollBy(el, x, y) {\n\tel.scrollLeft += x;\n\tel.scrollTop += y;\n}\n\n\nfunction clone(el) {\n\tlet Polymer = window.Polymer;\n\tlet $ = window.jQuery || window.Zepto;\n\n\tif (Polymer && Polymer.dom) {\n\t\treturn Polymer.dom(el).cloneNode(true);\n\t}\n\telse if ($) {\n\t\treturn $(el).clone(true)[0];\n\t}\n\telse {\n\t\treturn el.cloneNode(true);\n\t}\n}\n\n\nfunction setRect(el, rect) {\n\tcss(el, 'position', 'absolute');\n\tcss(el, 'top', rect.top);\n\tcss(el, 'left', rect.left);\n\tcss(el, 'width', rect.width);\n\tcss(el, 'height', rect.height);\n}\n\nfunction unsetRect(el) {\n\tcss(el, 'position', '');\n\tcss(el, 'top', '');\n\tcss(el, 'left', '');\n\tcss(el, 'width', '');\n\tcss(el, 'height', '');\n}\n\nfunction getChildContainingRectFromElement(container, options, ghostEl) {\n    const rect = {};\n\n\tArray.from(container.children).forEach(child => {\n\t\tif (!closest(child, options.draggable, container, false) || child.animated || child === ghostEl) return;\n\t\tconst childRect = getRect(child);\n\t\trect.left = Math.min(rect.left ?? Infinity, childRect.left);\n\t\trect.top = Math.min(rect.top ?? Infinity, childRect.top);\n\t\trect.right = Math.max(rect.right ?? -Infinity, childRect.right);\n\t\trect.bottom = Math.max(rect.bottom ?? -Infinity, childRect.bottom);\n\t});\n\trect.width = rect.right - rect.left;\n\trect.height = rect.bottom - rect.top;\n\trect.x = rect.left;\n\trect.y = rect.top;\n    return rect;\n}\n\nconst expando = 'Sortable' + (new Date).getTime();\n\n\nexport {\n\ton,\n\toff,\n\tmatches,\n\tgetParentOrHost,\n\tclosest,\n\ttoggleClass,\n\tcss,\n\tmatrix,\n\tfind,\n\tgetWindowScrollingElement,\n\tgetRect,\n\tisScrolledPast,\n\tgetChild,\n\tlastChild,\n\tindex,\n\tgetRelativeScrollOffset,\n\tindexOfObject,\n\tgetParentAutoScrollElement,\n\textend,\n\tisRectEqual,\n\tthrottle,\n\tcancelThrottle,\n\tscrollBy,\n\tclone,\n\tsetRect,\n\tunsetRect,\n\tgetContentRect,\n\tgetChildContainingRectFromElement,\n\texpando\n};\n"],"names":["clearTimeout","_throttleTimeout","el","Polymer","window","$","jQuery","Zepto","dom","cloneNode","clone","dst","src","key","hasOwnProperty","ctx","tagName","iterator","list","getElementsByTagName","i","n","length","childNum","options","includeDragEl","currentChild","children","style","display","Sortable","ghost","dragged","closest","draggable","container","ghostEl","rect","Array","from","forEach","child","animated","childRect","getRect","left","Math","min","Infinity","top","right","max","bottom","width","height","x","y","paddingLeft","parseInt","css","paddingTop","paddingRight","paddingBottom","clientWidth","clientHeight","offsetLeft","offsetTop","winScroller","getWindowScrollingElement","elMatrix","matrix","scaleX","a","scaleY","d","scrollLeft","scrollTop","parentNode","selector","index","previousElementSibling","nodeName","toUpperCase","matches","arr","obj","Number","rect1","rect2","round","elSide","parentSide","parent","getParentAutoScrollElement","elSideVal","visible","parentSideVal","last","lastElementChild","event","fn","removeEventListener","IE11OrLess","captureMode","addEventListener","callback","ms","args","arguments","_this","this","call","apply","setTimeout","name","state","classList","className","replace","R_SPACE","capture","passive","substring","msMatchesSelector","webkitMatchesSelector","_","getParentOrHost","host","document","nodeType","includeCTX","prop","val","defaultView","getComputedStyle","currentStyle","indexOf","selfOnly","appliedTransforms","transform","matrixFn","DOMMatrix","WebKitCSSMatrix","CSSMatrix","MSCSSMatrix","scrollingElement","documentElement","relativeToContainingBlock","relativeToNonStaticParent","undoScale","getBoundingClientRect","elRect","innerHeight","innerWidth","containerRect","includeSelf","elem","gotSelf","scrollWidth","scrollHeight","elemCSS","overflowX","overflowY","body","expando","Date","getTime"],"mappings":"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"}